"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoreResourceClient = exports.CoreClient = void 0;
const form_urlencoded_1 = __importDefault(require("form-urlencoded"));
const runtime_1 = require("./runtime");
const api_promise_1 = require("./api-promise");
const api_error_1 = require("./api-error");
const form_data_1 = require("./form-data");
const content_type_1 = require("./content-type");
class CoreClient {
    // private agent: any // TODO
    constructor(props) {
        this.baseUrl = props.baseUrl;
        this.auths = {};
        this.timeout = props.timeout;
    }
    registerAuth(name, provider) {
        this.auths[name] = provider;
    }
    applyAuths(cfg) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a;
            for (const name of (_a = cfg.auth) !== null && _a !== void 0 ? _a : []) {
                const provider = this.auths[name];
                if (provider) {
                    cfg = yield provider.applyAuth(cfg);
                }
            }
            return cfg;
        });
    }
    buildUrl(path) {
        const base = this.baseUrl.endsWith("/")
            ? this.baseUrl.slice(0, -1)
            : this.baseUrl;
        const cleanPath = path.startsWith("/") ? path.slice(1) : path;
        return `${base}/${cleanPath}`;
    }
    buildUrlFromCfg(cfg) {
        var _a, _b, _c;
        const base = this.baseUrl.endsWith("/")
            ? this.baseUrl.slice(0, -1)
            : this.baseUrl;
        const path = cfg.path.startsWith("/") ? cfg.path.slice(1) : cfg.path;
        let url = `${base}/${path}`;
        const searchParams = new URLSearchParams(((_a = cfg.query) !== null && _a !== void 0 ? _a : []).join("&"));
        for (const [key, val] of Object.entries((_c = (_b = cfg.opts) === null || _b === void 0 ? void 0 : _b.additionalQuery) !== null && _c !== void 0 ? _c : {})) {
            searchParams.append(key, val);
        }
        if (searchParams.toString().length > 0) {
            url += `?${searchParams.toString()}`;
        }
        return url;
    }
    applyHeaders(cfg, reqInit) {
        var _a, _b, _c;
        const finalHeaders = Object.assign(Object.assign(Object.assign(Object.assign({ "x-sideko-sdk-language": "Javascript", "x-sideko-runtime": runtime_1.RUNTIME.type }, ((_a = reqInit.headers) !== null && _a !== void 0 ? _a : {})), ((_b = cfg.headers) !== null && _b !== void 0 ? _b : {})), (cfg.contentType ? { "content-type": cfg.contentType } : {})), (_c = cfg.opts) === null || _c === void 0 ? void 0 : _c.additionalHeaders);
        reqInit.headers = finalHeaders;
        return reqInit;
    }
    encodeBodyByContentType(cfg, reqInit) {
        var _a, _b, _c, _d, _e, _f, _g;
        const contentTypeOverride = (_c = (_b = (_a = cfg.opts) === null || _a === void 0 ? void 0 : _a.additionalHeaders) === null || _b === void 0 ? void 0 : _b["content-type"]) !== null && _c !== void 0 ? _c : (_e = (_d = cfg.opts) === null || _d === void 0 ? void 0 : _d.additionalHeaders) === null || _e === void 0 ? void 0 : _e["Content-Type"];
        const contentType = (_f = contentTypeOverride !== null && contentTypeOverride !== void 0 ? contentTypeOverride : cfg.contentType) !== null && _f !== void 0 ? _f : "";
        if (typeof cfg.body === "undefined") {
            return reqInit;
        }
        else if (contentType.match(content_type_1.JSON_PATTERN)) {
            reqInit.body = JSON.stringify(cfg.body);
        }
        else if (contentType.match(content_type_1.TEXT_PATTERN)) {
            reqInit.body = String(cfg.body);
        }
        else if (contentType === content_type_1.MULTIPART_FORM) {
            // encode form
            const form = (0, form_data_1.createForm)(cfg.body);
            const headers = (_g = reqInit.headers) !== null && _g !== void 0 ? _g : {};
            if (runtime_1.RUNTIME.type === "node") {
                // explicitly set boundary
                headers["content-type"] = `${content_type_1.MULTIPART_FORM}; boundary=${form.getBoundary()}`;
            }
            else {
                // the browser should automatically set the content type
                delete headers["content-type"];
            }
            reqInit.headers = headers;
            reqInit.body = form;
        }
        else if (contentType === content_type_1.URL_FORM) {
            reqInit.body = (0, form_urlencoded_1.default)(cfg.body);
        }
        else {
            // we expect body to already be encoded in the correct fashion
            reqInit.body = cfg.body;
        }
        return reqInit;
    }
    buildRequestInit(cfg) {
        let reqInit = { method: cfg.method.toUpperCase() };
        reqInit = this.applyHeaders(cfg, reqInit);
        reqInit = this.encodeBodyByContentType(cfg, reqInit);
        if (cfg.withCredentials) {
            reqInit.credentials = "include";
        }
        return reqInit;
    }
    request(cfg) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            const fetcherFn = runtime_1.RUNTIME.type === "node" || typeof fetch !== "function"
                ? require("node-fetch").default
                : fetch;
            cfg = yield this.applyAuths(cfg);
            const reqInit = this.buildRequestInit(cfg);
            const url = this.buildUrlFromCfg(cfg);
            const timeout = (_b = (_a = cfg.opts) === null || _a === void 0 ? void 0 : _a.timeout) !== null && _b !== void 0 ? _b : this.timeout;
            const controller = new AbortController();
            let timeoutId;
            if (typeof timeout !== "undefined") {
                timeoutId = setTimeout(() => controller.abort(), timeout);
            }
            reqInit.signal = controller.signal;
            const response = yield fetcherFn(url, reqInit);
            if (timeoutId) {
                clearTimeout(timeoutId);
            }
            if (!response.ok) {
                throw new api_error_1.ApiError(cfg, response);
            }
            return response;
        });
    }
    makeRequest(cfg) {
        var _a, _b;
        return new api_promise_1.ApiPromise({
            responsePromise: this.request(cfg),
            responseRaw: (_a = cfg.responseRaw) !== null && _a !== void 0 ? _a : false,
            responseStream: (_b = cfg.responseStream) !== null && _b !== void 0 ? _b : false,
            responseSchema: cfg.responseSchema,
        });
    }
}
exports.CoreClient = CoreClient;
class CoreResourceClient {
    constructor(client) {
        this._client = client;
    }
}
exports.CoreResourceClient = CoreResourceClient;
